SUBROUTINE SUI.GET.TERM(MAT TermDef)
**************************************************************************
*Copyright (c) 2004-2012 Zumasys, Inc. as an unpublished work. All rights*
*reserved. You are free to use this code within your own applications,   *
*but you are expressly forbidden from selling or otherwise distributing  *
*this code without prior written consent. Portions based on original     *
*design by Joe Goldthwaite.                                              *
**************************************************************************
*
* MODULE: SUI.GET.TERM
* AUTHOR: PJS
* VERSION: 1.0.4
* CREATED: 06/01/2004
* UPDATED: 03/16/2012
*
* MAINTENANCE RECORD:
*
* 1.0.4
*  PJS 03/16/2012
*   Added MCU conversion to termtype returned by SYSTEM(7) cause
*   some Linux platforms return the TERM environment variable which
*   is usually lower case but our terminal definition item-ids are
*   upper case.
*   
* 1.0.3
*  PJS 11/08/2006
*   Added ON (ONWare MVON) platform support.
*
* 1.0.2
*  PJS 07/24/2006
*   Added OI (OpenInsight CTO) platform support.
*
* 1.0.1
*  PJS 07/20/2004
*   Added code to check for ambiguous key strings, where one command
*   is a prefix for another command (such as the ESC key). The command
*   number of ambibuous prefix is set to the negative of its actual
*   value so that it can be disambiguated by the input routine by
*   using a timed input function.
*
*************************************************************************
*************************************************************************
*
* SMART USER INTERFACE Terminal Set UP
*
* This subroutine reads and compiles the terminal definition
* into the TermDef array based on the current TERMTYPE. This
* subroutine should be called once in the main program. Be
* sure to INCLUDE SUI.TERMDEF in the main program.
*
*************************************************************************
*************************************************************************
*
$INCLUDE SUI.CASING ;* Keystroke decoding is case-sensitive
*
$INCLUDE SUI.TERMDEF
*
EQU AM TO CHAR(254), VM TO CHAR(253), SVM TO CHAR(252)
EQU ESC TO CHAR(27), STX TO CHAR(2), CR TO CHAR(13), EM TO CHAR(25)
EQU ASCII.TBL TO 'NULSOHSTXETXEOTENQACKBELBSHTLFVTFFCRSOSIDLEDC1DC2DC3DC4NAKSYNETBCANEMSUBESCFSGSRSUSSPACEDEL';*#DEFAULT#*
EQU TERM.CMD.NBRS TO '0123456789101112131415161718192021222324252627282931323334353637383940414243444546515253545556575859606162636465666768697071727374';*#DEFAULT#*
EQU TERM.CMD.STRS TO 'USEDESCATTRTYPEOFFSETHICTLNORMWDNORMHTEXTWDEXTHTPAGESSPECIALRESETNORMALEXTENDEDCSRONCSROFFCSRLINECSRBLKAUXONAUXOFFSELPAGECLEARCEOSCEOLINSCHRDELCHRINSLINEDELLINECPYBLKCLRBLKNVBVRVRBVUVUBVURVURBVDVDBVDRVDRBVDUVDUBVDURVDURBVGRONGROFFGHGVGTLGTIGTRGLIGCIGRIGBLGBIGBRDGHDGVDGTLDGTIDGTRDGLIDGCIDGRIDGBLDGBIDGBR';*#DEFAULT#*
EQU TERM.KEY.NBRS TO '123456789101112131516171819202122232425262728316162636465666768697071727374757681828384858687888990919293949596151152153154155156';*#DEFAULT#*
EQU TERM.KEY.STRS TO 'ENTERBKSPUPDOWNLEFTRIGHTPGUPPGDNHOMEENDINSDELTABESCAPESENTERSBKSPSUPSDOWNSLEFTSRIGHTSPGUPSPGDNSHOMESENDSINSSDELSTABATTF1F2F3F4F5F6F7F8F9F10F11F12F13F14F15F16SF1SF2SF3SF4SF5SF6SF7SF8SF9SF10SF11SF12SF13SF14SF15SF16LEFTBUTTONRIGHTBUTTONMIDBUTTONDBLLEFTBUTTONDBLRIGHTBUTTONDBLMIDBUTTON';*#DEFAULT#*
*#OI#*EQU ASCII.TBL TO 'NULSOHSTXETXEOTENQACKBELBSHTLFVTFFCRSOSIDLEDC1DC2DC3DC4NAKSYNETBCANEMSUBESCFSGSRSUSSPACEDEL'
*#OI#*EQU TERM.CMD.NBRS TO '0123456789101112131415161718192021222324252627282931323334353637383940414243444546515253545556575859606162636465666768697071727374'
*#OI#*TERM.CMD.STRS = 'USEDESCATTRTYPEOFFSETHICTLNORMWDNORMHTEXTWDEXTHTPAGESSPECIALRESETNORMALEXTENDEDCSRONCSROFFCSRLINECSRBLKAUXONAUXOFFSELPAGECLEARCEOSCEOLINSCHRDELCHRINSLINEDELLINECPYBLKCLRBLK'
*#OI#*TERM.CMD.STRS = TERM.CMD.STRS : 'NVBVRVRBVUVUBVURVURBVDVDBVDRVDRBVDUVDUBVDURVDURBVGRONGROFFGHGVGTLGTIGTRGLIGCIGRIGBLGBIGBRDGHDGVDGTLDGTIDGTRDGLIDGCIDGRIDGBLDGBIDGBR'
*#OI#*EQU TERM.KEY.NBRS TO '123456789101112131516171819202122232425262728316162636465666768697071727374757681828384858687888990919293949596151152153154155156'
*#OI#*TERM.KEY.STRS = 'ENTERBKSPUPDOWNLEFTRIGHTPGUPPGDNHOMEENDINSDELTABESCAPESENTERSBKSPSUPSDOWNSLEFTSRIGHTSPGUPSPGDNSHOMESENDSINSSDELSTABATT'
*#OI#*TERM.KEY.STRS = TERM.KEY.STRS : 'F1F2F3F4F5F6F7F8F9F10F11F12F13F14F15F16SF1SF2SF3SF4SF5SF6SF7SF8SF9SF10SF11SF12SF13SF14SF15SF16'
*#OI#*TERM.KEY.STRS = TERM.KEY.STRS : 'LEFTBUTTONRIGHTBUTTONMIDBUTTONDBLLEFTBUTTONDBLRIGHTBUTTONDBLMIDBUTTON'
*#ON#*ASCII.TBL = 'NUL]SOH]STX]ETX]EOT]ENQ]ACK]BEL]BS]HT]LF]VT]FF]CR]SO]SI]DLE]DC1]DC2]DC3]DC4]NAK]SYN]ETB]CAN]EM]SUB]ESC]FS]GS]RS]US]SPACE]DEL'
*#ON#*CONVERT ']' TO @VM IN ASCII.TBL
*#ON#*TERM.CMD.NBRS = '0]1]2]3]4]5]6]7]8]9]10]11]12]13]14]15]16]17]18]19]20]21]22]23]24]25]26]27]28]29]31]32]33]34]35]36]37]38]39]40]41]42]43]44]45]46]51]52]53]54]55]56]57]58]59]60]61]62]63]64]65]66]67]68]69]70]71]72]73]74'
*#ON#*CONVERT ']' TO @VM IN TERM.CMD.NBRS
*#ON#*TERM.CMD.STRS = 'USE]DESC]ATTRTYPE]OFFSET]HICTL]NORMWD]NORMHT]EXTWD]EXTHT]PAGES]SPECIAL]RESET]NORMAL]EXTENDED]CSRON]CSROFF]CSRLINE]CSRBLK]AUXON]AUXOFF]SELPAGE]CLEAR]CEOS]CEOL]INSCHR]DELCHR]INSLINE]DELLINE]CPYBLK]CLRBLK]NV]BV]RV]RBV]UV]UBV]URV]URBV]DV]DBV]DRV]DRBV]DUV]DUBV]DURV]DURBV]GRON]GROFF]GH]GV]GTL]GTI]GTR]GLI]GCI]GRI]GBL]GBI]GBR]DGH]DGV]DGTL]DGTI]DGTR]DGLI]DGCI]DGRI]DGBL]DGBI]DGBR'
*#ON#*CONVERT ']' TO @VM IN TERM.CMD.STRS
*#ON#*TERM.KEY.NBRS = '1]2]3]4]5]6]7]8]9]10]11]12]13]15]16]17]18]19]20]21]22]23]24]25]26]27]28]31]61]62]63]64]65]66]67]68]69]70]71]72]73]74]75]76]81]82]83]84]85]86]87]88]89]90]91]92]93]94]95]96]151]152]153]154]155]156'
*#ON#*CONVERT ']' TO @VM IN TERM.KEY.NBRS
*#ON#*TERM.KEY.STRS = 'ENTER]BKSP]UP]DOWN]LEFT]RIGHT]PGUP]PGDN]HOME]END]INS]DEL]TAB]ESCAPE]SENTER]SBKSP]SUP]SDOWN]SLEFT]SRIGHT]SPGUP]SPGDN]SHOME]SEND]SINS]SDEL]STAB]ATT]F1]F2]F3]F4]F5]F6]F7]F8]F9]F10]F11]F12]F13]F14]F15]F16]SF1]SF2]SF3]SF4]SF5]SF6]SF7]SF8]SF9]SF10]SF11]SF12]SF13]SF14]SF15]SF16]LEFTBUTTON]RIGHTBUTTON]MIDBUTTON]DBLLEFTBUTTON]DBLRIGHTBUTTON]DBLMIDBUTTON'
*#ON#*CONVERT ']' TO @VM IN TERM.KEY.STRS
*#MVON#*ASCII.TBL = 'NUL]SOH]STX]ETX]EOT]ENQ]ACK]BEL]BS]HT]LF]VT]FF]CR]SO]SI]DLE]DC1]DC2]DC3]DC4]NAK]SYN]ETB]CAN]EM]SUB]ESC]FS]GS]RS]US]SPACE]DEL'
*#MVON#*CONVERT ']' TO @VM IN ASCII.TBL
*#MVON#*TERM.CMD.NBRS = '0]1]2]3]4]5]6]7]8]9]10]11]12]13]14]15]16]17]18]19]20]21]22]23]24]25]26]27]28]29]31]32]33]34]35]36]37]38]39]40]41]42]43]44]45]46]51]52]53]54]55]56]57]58]59]60]61]62]63]64]65]66]67]68]69]70]71]72]73]74'
*#MVON#*CONVERT ']' TO @VM IN TERM.CMD.NBRS
*#MVON#*TERM.CMD.STRS = 'USE]DESC]ATTRTYPE]OFFSET]HICTL]NORMWD]NORMHT]EXTWD]EXTHT]PAGES]SPECIAL]RESET]NORMAL]EXTENDED]CSRON]CSROFF]CSRLINE]CSRBLK]AUXON]AUXOFF]SELPAGE]CLEAR]CEOS]CEOL]INSCHR]DELCHR]INSLINE]DELLINE]CPYBLK]CLRBLK]NV]BV]RV]RBV]UV]UBV]URV]URBV]DV]DBV]DRV]DRBV]DUV]DUBV]DURV]DURBV]GRON]GROFF]GH]GV]GTL]GTI]GTR]GLI]GCI]GRI]GBL]GBI]GBR]DGH]DGV]DGTL]DGTI]DGTR]DGLI]DGCI]DGRI]DGBL]DGBI]DGBR'
*#MVON#*CONVERT ']' TO @VM IN TERM.CMD.STRS
*#MVON#*TERM.KEY.NBRS = '1]2]3]4]5]6]7]8]9]10]11]12]13]15]16]17]18]19]20]21]22]23]24]25]26]27]28]31]61]62]63]64]65]66]67]68]69]70]71]72]73]74]75]76]81]82]83]84]85]86]87]88]89]90]91]92]93]94]95]96]151]152]153]154]155]156'
*#MVON#*CONVERT ']' TO @VM IN TERM.KEY.NBRS
*#MVON#*TERM.KEY.STRS = 'ENTER]BKSP]UP]DOWN]LEFT]RIGHT]PGUP]PGDN]HOME]END]INS]DEL]TAB]ESCAPE]SENTER]SBKSP]SUP]SDOWN]SLEFT]SRIGHT]SPGUP]SPGDN]SHOME]SEND]SINS]SDEL]STAB]ATT]F1]F2]F3]F4]F5]F6]F7]F8]F9]F10]F11]F12]F13]F14]F15]F16]SF1]SF2]SF3]SF4]SF5]SF6]SF7]SF8]SF9]SF10]SF11]SF12]SF13]SF14]SF15]SF16]LEFTBUTTON]RIGHTBUTTON]MIDBUTTON]DBLLEFTBUTTON]DBLRIGHTBUTTON]DBLMIDBUTTON'
*#MVON#*CONVERT ']' TO @VM IN TERM.KEY.STRS
*
* READ THE TERMINAL DEFINITION
OPEN 'SUIBP' TO FN.TERM ELSE PRINT 'Unable to open SUIBP!'; STOP
MAT TermDef = ''
ID = 'TERMDEF.' : OCONV(SYSTEM(7),'MCU') ;* KEY IS DERIVED FROM TERM TYPE
READ Z FROM FN.TERM,ID ELSE PRINT "Terminal definition '" : ID : "' not found!"; STOP
*
* COMPILE THE TERMINAL DEFINITION ARRAY
I = 0
N = DCOUNT(Z,AM)
LOOP
 I = I + 1
WHILE I <= N DO
 Ln = TRIM(Z<I>)
 IF Ln NE '' AND Ln[1,1] NE '*' THEN
  K = INDEX(Ln,':',1)
  Lbl = OCONV(TRIM(Ln[1,K-1]),'MCU')
  Source = TRIM(Ln[K+1,999])
  LOCATE(Lbl, TERM.CMD.STRS, 1; Pos) THEN
   Idx = TERM.CMD.NBRS<1,Pos>
   IF Idx > 0 THEN
    * COMPILE TERMINAL COMMAND STRING
    IF Idx > 10 THEN
     GOSUB COMPILE
    END ELSE
     K = INDEX(Source,'*',1)
     IF K = 0 THEN K = 999
     Object = TRIM(Source[1,K-1])
    END
    TermDef(Idx) = Object
   END ELSE
    * THIS IS A SYNONYM - READ THE ACTUAL DEFINITION
    K = INDEX(Source,'*',1)
    IF K THEN Source = TRIM(Source[1,K-1])
    ID = 'TERMDEF.' : Source
    READ Z FROM FN.TERM,ID ELSE PRINT "Terminal definition '" : ID : "' not found!"; STOP
    N = DCOUNT(Z,AM)
    I = 0
   END
  END ELSE
   LOCATE(Lbl, TERM.KEY.STRS, 1; Pos) THEN
    * COMPILE KEYBOARD STRING
    Idx = TERM.KEY.NBRS<1,Pos>
    GOSUB COMPILE
    IF Object NE '' THEN
     LOCATE(Object, TERM.INPSTR, 1; Pos; 'AL') ELSE
      TERM.INPSTR = INSERT(TERM.INPSTR, 1, Pos; Object)
      TERM.CMDSTR = INSERT(TERM.CMDSTR, 1, Pos; Idx)
     END
    END
   END
  END
 END
REPEAT
* COERCE NUMERIC VARIABLES FOR FASTEST ACCESS
FOR I = 2 TO 10
 IF NUM(TermDef(I)) THEN TermDef(I) = TermDef(I) + 0 ELSE TermDef(I) = 0
NEXT I
* ADD LEADING VM TO KEY STRINGS (MAKES USING INDEX EASIER IN INPUT.CHAR)
TERM.INPSTR = VM : TERM.INPSTR
TERM.CMDSTR = VM : TERM.CMDSTR
* CHECK FOR AMBIGUOUS KEY STRINGS (LEADING ESC CHAR VS. ESC KEY)
X = TERM.INPSTR
N = DCOUNT(X,VM)
FOR I = 2 TO N
 Q = VM : X<1,I>
 X<1,I> = '' 
 IF INDEX(X, Q, 1) THEN TERM.CMDSTR<1,I> = -TERM.CMDSTR<1,I> ;* FLAG IT
NEXT I 
* SET INITIAL STATE
TERM.WIDTH = TERM.NORMWD
TERM.HEIGHT = TERM.NORMHT
TERM.PAGE = 0
TERM.ECHO = 1
TERM.CURSOR = 1
*
* CHECK FOR SPECIAL ACCUTERM FEATURES
*
IF TERM.SPECIAL THEN
 CALL FTVSINF('',Prod,Rls,Caps,'','','','')
 * WORK AROUND BUG IN ATIE NOT RETURNING "S"
 IF Prod = 5 AND INDEX(Caps,'S',1) = 0 THEN Caps = Caps : 'S'
 IF Rls = 5.201 AND INDEX(Caps,'S',1) THEN
  * WORK AROUND BUG IN 5.2a NOT RETURNING "B" PROPERLY
  Scr = ''
  Scr = Scr : 'On Error Resume Next' : EM
  Scr = Scr : 'X = InitSession.Settings.AttributeMask And &h00C0' : EM
  Scr = Scr : 'InitSession.Output CStr(X) & vbCR'
  ECHO OFF
  PROMPT ''
  PRINT ESC : STX : 'P' : Scr : CR :
  INPUT ANS:
  PROMPT '?'
  ECHO ON
  IF ANS THEN Caps = Caps : 'B' ;* borders are enabled, so add B to the Caps list
 END
 TERM.SPECIAL = Caps ;* SAVE THE CAPABILITIES STRING
END ELSE
 TERM.SPECIAL = ''
END
*
RETURN
*
!
COMPILE: * COMPILE A TERMINAL DEFINITION ITEM FROM ASCII SOURCE
Object = ''
Cnt = COUNT(Source,' ') + (Source NE '')
FOR X = 1 TO Cnt
 Fld = FIELD(Source,' ',X)
 BEGIN CASE
  CASE OCONV(Fld[1,5],'MCU') = 'CHAR('
   * CHAR FUNCTION
   Q = CHAR(FIELD(FIELD(Fld,'(',2),')',1))
  CASE Fld[1,1] = "'" OR Fld[1,1] = '"'
   * QUOTED LITERAL
   LOOP
    K = INDEX(Fld,Fld[1,1],2)
   WHILE K = 0 AND X < Cnt DO
    X = X + 1
    Fld = Fld : ' ' : FIELD(Source,' ',X)
   REPEAT
   Q = Fld[2,K-2]
  CASE Fld[1,1] = '*'
   * COMMENT
   Q = ''
   X = Cnt
  CASE 1
   * CONTROL CHARACTER OR VARIABLE NAME
   Fld = OCONV(Fld,'MCU')
   LOCATE(Fld, ASCII.TBL, 1; Pos) THEN
    * CONTROL CHARACTER NAME FOUND
    IF Pos > 33 THEN Pos = Pos + 94
    Q = CHAR(Pos-1)
   END ELSE
    * CHECK FOR VARIABLE NAME
    BEGIN CASE
     CASE Lbl = 'SELPAGE'
      Fldx = FIELD(Fld,'+',1)
      IF Fldx = 'PG' THEN
       Q = SVM : Fld : SVM
      END ELSE
       Object = ''
       RETURN
      END
     CASE Lbl = 'CPYBLK'
      Fldx = FIELD(Fld,'+',1)
      IF Fldx = 'SRC' OR Fldx = 'LEFT' OR Fldx = 'TOP' OR Fldx = 'RIGHT' OR Fldx = 'BOTTOM' OR Fldx = 'DEST' OR Fldx = 'COL' OR Fldx = 'ROW' THEN
       Q = SVM : Fld : SVM
      END ELSE
       Object = ''
       RETURN
      END
     CASE Lbl = 'CLRBLK'
      Fldx = FIELD(Fld,'+',1)
      IF Fldx = 'LEFT' OR Fldx = 'TOP' OR Fldx = 'RIGHT' OR Fldx = 'BOTTOM' THEN
       Q = SVM : Fld : SVM
      END ELSE
       Object = ''
       RETURN
      END
     CASE 1
      Object = ''
      RETURN
    END CASE
   END
 END CASE
 Object = Object : Q
NEXT X
RETURN
END